<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Test</title>
</head>
<body>
<script type="importmap">
        {
            "imports": {
                "streamx": "https://esm.run/streamx",
                "brittle": "https://esm.run/brittle",
                "b4a": "https://esm.run/b4a",
                "duplex-through": "https://esm.run/duplex-through"
            }
        }

</script>
<script type="module">
    import {fromWeb, toWeb} from "./index.js";
    import {Readable, Writable} from "streamx";
    import {test} from "brittle";
    import b4a from "b4a";

    test('streamx to web readable stream', async t => {
        t.plan(7)

        const r = new Readable()
        const buffered = []
        let ended = 0

        r.push('hello')
        r.push('world')
        r.push(null)

        const webStreamReadable = toWeb(r);
        const reader = webStreamReadable.getReader();

        r.on("close", () => t.pass("closed", "Streamx closed successfully"));
        r.on('end', () => ended++)

        while (true) {
            const {value, done} = await reader.read();
            if (value) buffered.push(b4a.toString(value));
            if (done) break;
        }

        t.is(buffered[0] + buffered[1], "helloworld", "Received helloworld streamx->ReadableStream");
        t.is(ended, 1, "streamx end event was emitted")
        t.ok(r.destroyed, "streamx destroyed properly");

        reader.closed.then(
            () => t.pass("ReadableStream closed")
        );

        t.ok(webStreamReadable.locked, "ReadableStream has lock still");
        reader.releaseLock();
        t.absent(webStreamReadable.locked, "ReadableStream lock released");
    });

    test('web readable stream to streamx', async t => {
        t.plan(6);
        const webStreamReadable = new ReadableStream({
            start(controller) {
                controller.enqueue(b4a.from("hello"));
                controller.enqueue(b4a.from("world"));
                controller.close();
            }
        });

        const streamxReadable = fromWeb(webStreamReadable);
        const buffered = [];
        let ended = 0

        streamxReadable.once('end', () => ended++)

        streamxReadable.on("data", o => {
            buffered.push(b4a.toString(o));
        });

        streamxReadable.once("close", async () => {
            t.pass("closed", "Streamx closed successfully");
            t.is(buffered[0] + buffered[1], "helloworld", "Received helloworld ReadableStream->streamx");
            t.is(ended, 1, "streamx end event was emitted")
            t.ok(streamxReadable.destroyed, "streamx destroyed properly");
            t.ok(webStreamReadable.locked, "Web stream is still locked to instance, must be closed");
            t.comment("streamx may have already closed by now but the webstream needs some cleanup")
            await streamxReadable.close();
            t.absent(webStreamReadable.locked, "Web stream unlocked.");
        });
    });

    test('web readable stream to streamx with streamx options', async t => {
        t.plan(6);
        const webStreamReadable = new ReadableStream({
            start(controller) {
                controller.enqueue(
                    b4a.from(
                        JSON.stringify({hello: "world"})
                    )
                );

                controller.enqueue(
                    b4a.from(
                        JSON.stringify({foo: "bar"})
                    )
                );

                controller.close();
            }
        });

        const streamxReadable = fromWeb(webStreamReadable, {
            map(o) {
                return JSON.parse(
                    b4a.toString(o)
                )
            }
        });
        const buffered = [];
        let ended = 0

        streamxReadable.once('end', () => ended++)

        streamxReadable.on("data", o => {
            buffered.push(o);
        });

        streamxReadable.once("close", async () => {
            t.pass("closed", "Streamx closed successfully");
            t.is(buffered[0].hello + buffered[1].foo, "worldbar", "Received worldbar ReadableStream->streamx");
            t.is(ended, 1, "streamx end event was emitted")
            t.ok(streamxReadable.destroyed, "streamx destroyed properly");
            t.ok(webStreamReadable.locked, "Web stream is still locked to instance, must be closed");
            t.comment("streamx may have already closed by now but the webstream needs some cleanup")
            await streamxReadable.close();
            t.absent(webStreamReadable.locked, "Web stream unlocked.");
        });
    });

    test('fromWeb: streamx duplex mode', async t => {
        t.plan(10);
        let ended = 0;

        const readBuffer = [];
        const writeBuffer = [];

        const webStreamReadable = new ReadableStream({
            start(controller) {
                 controller.enqueue("hello");
                controller.enqueue("world");
                controller.close();
            }
        });

        const webStreamWritable = new WritableStream({
            write(val) {
                // ReadableStream (web) -> Duplex (readable streamx) -> Writable (writable streamx) -> WritableStream (web)
                readBuffer.push(val);
            }
        });
        
        const writer = webStreamWritable.getWriter();

        const streamDuplex = fromWeb(webStreamReadable, {
            // Adding this 'write' function turns it into duplex.
            write(val, cb) {
                // this receives the 'power overwhelming' and 'i'd rather be sailing'
                // strings from below.
                writeBuffer.push(val);
                cb();
            },
            // you can then use streamx mapper function for the respective direction
            mapWritable(val) {
                // this capitalizes the 'power overwhelming' and 'i'd rather be sailing'
                return val.toUpperCase();
            },
            mapReadable(val) {
                // this capitalizes the 'hello' and 'world' from web api readable.
                return val.toUpperCase();
            }
        });

        // We pipe the readable part of duplex into this writable to test
        // that piping operations works.
        const writable = new Writable({
            write(val, cb) 
                writer.write(val);
                cb();
            }
        });

        // The 'readable' part of the duplex is piped to the 'writable streamx' (above this line)
        // Which then gets piped into the writable web stream.
        streamDuplex.pipe(writable);

        // This writes to the duplex (writable streamx) which
        // does not interact with the readable part of the duplex
        streamDuplex.write("power overwhelming");
        streamDuplex.write("I'd rather be sailing");
        streamDuplex.end();

        streamDuplex.once("end", () => ended++);
        streamDuplex.once("close", async () => {
            const [writeDuplex1, writeDuplex2, writeDuplex3] = writeBuffer;
            const [readDuplex1, readDuplex2, readDuplex3] = readBuffer;

            t.is(writeDuplex1, "POWER OVERWHELMING", "Written to the duplex");
            t.is(writeDuplex2, "I'D RATHER BE SAILING", "Written to the duplex.");
            t.absent(writeDuplex3);

            t.is(readDuplex1, "HELLO", "Read from the web stream and using mapReadable streamx option.");
            t.is(readDuplex2, "WORLD", "Read from the web stream and using mapReadable streamx option.");
            t.absent(readDuplex3);

            t.is(ended, 1, "duplex end event was emitted")
            t.ok(streamDuplex.destroyed, "streamx destroyed properly");
            t.ok(webStreamReadable.locked, "Web stream is still locked to instance, must be closed");
            t.comment("streamx may have already closed by now but the webstream needs some cleanup");

            await streamDuplex.close();
            t.absent(webStreamReadable.locked, "Web stream unlocked.");
        });
    });
</script>
</body>
</html>
